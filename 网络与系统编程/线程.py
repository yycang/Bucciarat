###########
# 线程和进程
###########

"""

如果进程是一个程序启动成了进程, 那么线程就是进程中的一个个任务,
比如打开QQ是启动一个进程, 那聊天功能, 发图功能, 以及多个聊天窗口都是一条条线程

一个程序至少会有一条进程, 而一个进程中至少会有一条线程
线程占用的资源比进程小, 所以多线程的并发性比较高
进程在执行过程中拥有独立的内存单元, 所以多个线程共享内存, 会提升程序运行的效率
线程不能独立运行, 必须依赖在进程中

"""

#################
# 多线程-threading
#################

# 启动多线程将一个函数传入实例中, 然后start()方法启动他

import threading
import time


def hello():
    print('线程%s启动,' % threading.current_thread().name)
    for i in range(5):
        i += 1
        print('线程%s运行: %s' % (threading.current_thread().name, i))
        time.sleep(1)
    print('线程%s结束' % threading.current_thread().name)

if __name__ == '__main__':
    print('线程%s启动' % threading.current_thread().name)
    t = threading.Thread(target=hello, name='HelloThread')
    t.start()
    t.join()
    print('线程%s结束' % threading.current_thread().name)

# 一个进程中至少有一个线程, 所以那个线程称为主线程, current_thread()会返回当前线程的实例
# 上个例子在创建线程时给线程取了个名字, 如果不取名字的会默认为Thread-N, N为递增的


###########
# 线程非安全
##########

"""

进程中的全局变量是多线程共享的, 这点在多线程之间的数据传递比多进程要好

但是, 多线程之间对数据的更改会导致全局变量的混乱不堪, 即线程不安全

解决此问题的方法就是在某个线程要更改共享数据时, 给线程上锁, 上锁的同时其他线程无法更改, 直到释放改资源

这种加锁的方式能让同一时间只能由一个线程进行操作

"""

# 创建锁
lock = threading.Lock()
# 锁定
lock.acquire()      # 有个block参数, 默认为True阻塞, 改成False时不会阻塞, 无论是否能上锁都会往下执行代码
# 释放锁
lock.release()

# 这种加锁的方式会保证关键部分的代码能单独的按顺序完整的执行
# 但是会有缺点是加锁的地方只会单线程执行, 效率会降低; 其次可能会造成死锁

# 死锁的问题是在两个线程中都分别添加了锁, 但是需要解锁的条件都是对方的锁解了, 此时会造成死锁, 谁也不让谁
# 这种情况解决方法: 1.银行家算法 2.添加超时时间


###############
# 生产者消费者模式
###############

# Queue在多线程通信中也扮演着很重要的角色
# 生产者消费者模式就是在一个线程中生产数据, 一个线程中处理数据, 但是如果生产的效率大于消费的效率, 就会让消费处理完, 生产再进行生产
# 这样会通过一个阻塞队列来平衡二者的关系, 生产者会将数据扔到了阻塞队列, 而消费者只需要从阻塞队列中取数据即可

# 同时也能用协程来完成生产者消费者模式
# 协程又称微线程, 线程是执行一个子程序, 或者是函数, 它是调用一个入口, 也是一个出口返回, 调用的顺序是明确的
# 协程看上去也是子程序, 但是它会从子程序中中断, 执行其他子程序, 然后适当的时候再回来执行这个子程序, 看上去就像这个两个子程序协作运行一样
# 优点是1: 效率快, 2:不用担心变量冲突, 因为是一个线程不需要使用锁机制

# 在python中使用协程要用到生成器
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'


def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n += 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)


######
# GIL
######

"""

Global Interpreter Lock 全局解释器锁

因为有GIL的存在, 多线程在多核CPU中只会占用一核

原因是在python线程执行的时候, 必须先获取GIL锁, 执行后解释器会自动释放锁, 即使多线程在100核CPU上跑, 也只能用一核

解决方法是: 用C扩展去写, 但是不推荐

多进程依然会实现多核任务, 因为每个进程都有各自独立的GIL锁, 进程之间互不干扰

"""