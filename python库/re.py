"""

re: 正则表达式
关于正则经常听到的流传的一句话就是: 当你有个问题需要用正则来解决的时候,那么你就有两个问题了 - -
而python核心编程第二版这本书更是用整整一个大章节来讲述了re这个模块,足以证明他的难度和重要性

本笔记涉及到的正则表达式模块内容:
1.正则表达式的定义
2.正则表达式使用的特殊字符和符号
3.正则表达式核心函数和用法
4.待续...

"""

import re

#################
# 1.正则表达式的定义
#################

"""

事先定义好一些特定的字符和一些字符之间的组合, 使之产生一定的规律
用这些"规则字符串"来对字符串进行过滤的逻辑

正则说简单也很简单,他可以不包含任何特殊符号去匹配其他符号,仅自身所描述的
例如: 'abc' 能匹配到  'abc'
但正则的强大之处还是在于他的特殊符号的应用

"""


#############################
# 2.正则表达式使用的特殊字符和符号
#############################

"""

符号与字符:

管道符号  |     匹配re1或者re2等被管道分割的多个
例如: bat|bet|bit     可以匹配到bat,bet,bit

点字符   .     匹配任意一个单个字符(换行符除外)
例如: f.o         可以匹配f和o之间任意的字符,例如 fao,f9o,f-o等

边界匹配
^   或者  \A          匹配开头
$   或者  \Z          匹配结尾
例如: ^Are            可以匹配任意以Are开头的字符串
      gg$           可以匹配任意以gg结尾的字符串
    ^hello,world$   可以匹配出仅仅hello,world组成的字符串

\b      匹配单词边界,在一个单词的开头
\B      匹配在一个单词的中间的模式
例如:  \bthe          任何以"the"开头的字符串
      \bthe\b         仅匹配单词"the"
      \Bthe           匹配任意包含"the"但是不以"the"开头的单词

****************
注意: \b 在ASCII字符中代表退格键,但 \b 也是一个正则表达式的特殊符号
为了让RE编译器把两个字符 \b 当成你想要表达的字符串,而不是一个退格键
需要用到 \ 来对其进行转义,即 \\b(或者使用原始字符串r也可以)
****************

方括号     []      匹配方括号里面的任意一个字符
例如: b[abc]id[uio]   可以匹配出baidu

连字符     -       表示一个字符的范围,在[]中使用
例如: A-Z,a-z,0-9分别代表大写字母,小写字母和十进制数字
z.[0-9]     字符z后面跟任意一个字符,然后加上一个十进制数字

上箭头     ^       表示不匹配[]中的任意字符
例如:
[^aeuio]    表示一个非元音字符
[^\t\n]     除了tab键或者换行符以外的任意一个字符

重复匹配:
*       匹配前面正则表达式出现的0次或0次以上
+       匹配前面正则表达式出现至少一次,即1次或者1次以上
?       匹配前面正则表达式出现的0次或1次
{m}     匹配前面正则表达式出现m次
{n,m}   匹配前面正则表达式出现n到m次
例如:
[dn]ot?         字符d或者n,后面跟上一个o, 然后是一个出现1次或者0次的t, 可以匹配到do, dot, no, not
0?[1-9]         匹配1-9任意一个数字,前面有可能有个0
[0-9]{15,16}    15或者16位数字
</?[^>]+>       匹配所有合法或者无效的html标签的字符串

*************
?有两种含义,单独使用时表示匹配出现0次或者1次
紧跟在表示重复的元字符后面,表示要求匹配的字符串越短越好(即非贪婪匹配)
*************

特殊字符:
\d      匹配任意数字,和[0-9]的作用一样
\D      匹配任意非数字,作用等同与[^0-9]
\w      匹配任意数字字母字符,等同与[A-Za-z0-9_]
\W      是\w的反义
\s      匹配任何空白符,和[\n\t\r\v\f]相同
\S      是\s的反义
例如:
\w+-\d+             一个字母或字符组成的字符串和至少一个数字, 由连字符连着
\d{3}-\d{3}-\d{4}   美国电话号码,匹配400-123-1234
\w+@\w+\.com        匹配一个简单格式的邮箱xxx@qq.com

***********
\n: 换行; \t: 水平制表符,一个tab键; \r: 回车;  \v: 垂直制表符(即12\v34,34到下一行输出); \f: 换页符
***********

圆括号     ()      可以实现对正则表达式进行分组,或者匹配子组的作用
使用场景:如果想对匹配下来的两部分分别保存
例如: \d+-\w+ 想对第一部分和第二部分分别保存,就可以写成(\d+)-(\w+)

"""


######################
# 正则表达式核心函数和用法
######################

"""

compile(pattern,flags=0)            对正则pattern进行编译,flags是可选标识符,返回一个regex对象
match(pattern,string,flags=0)       尝试用正则模式pattern匹配字符串string,如果成功返回一个匹配对象,失败返回None
search(pattern,string,flags=0)      在字符串string搜索pattern的第一次出现,如果成功返回一个匹配对象,否则返回None
findall(pattern,string,[,flags])    在字符串string中搜索pattern的所有出现,返回一个匹配对象的列表
finditer(pattern,string,[,flags])   和findall相同,不过返回的不是列表而是迭代器,对于每个匹配返回一个匹配对象
split(pattern,string,max=0)         根据正则表达式pattern中的分隔符把字符string分割成一个列表,返回成功匹配的列表,最多分割max次
sub(pattern,repl,string,max=0)      把string中所有正则pattern的部分替换成repl,默认替换所有匹配的地方

group(num=0)        返回全部匹配对象
groups()            返回一个包含全部匹配的子组的元祖

"""

# compile()编译正则表达式
# 正则表达式必须先被编译成regex对象, compile()可以预先进行编译,但不是必须的

# match()和search()
re.match('good', 'very good')   # None

re.search('good', 'very good').group()  # 'good'

"""

match和search的区别是match()会尝试从字符串开头进行匹配,
上例中以v开头, 而匹配到g肯定是失败的

search()将会对整个字符串进行搜索, 而不只尝试在开头进行匹配

"""

# group()和groups()
# group()返回所有对象,或者指定的子组; 而groups返回一个元组,包含所有的子组

re.match('hello', 'hello,world').group()    # 'hello'

re.match('hello', 'hello,world').groups()   # (), 因为并没有子组, 所以返回空元组, 子组的建立用()

re.match('(hel)lo', 'hello,world').groups()  # ('hel', )


# findall()总会返回一个列表, 如果没有匹配到, 返回一个空列表

re.findall('car', 'carry,car')  # ['car', 'car']

# sub()和subn()进行替换和搜索

re.sub('x', 'mr.wang', 'x are very happy today, x go to bed')   # 'mr.wang are very happy today, mr.wang go to bed'

re.subn('x', 'mr.wang', 'x are very happy today, x go to bed')  # ('mr.wang are very happy today, mr.wang go to bed', 2)

"""

sub()将替换后的字符串返回
而subn()作用相似, 但它多返回了一个数字, 代表了替换的次数

"""

# split()进行分割

re.split('\.', '192.168.172.0')     # ['192', '168', '172', '0']


"""

**************
贪婪匹配与非贪婪匹配
**************

正则表达式中默认是贪婪匹配, 也就是正则使用的通配符,
按照从左到右的顺序抓取值的时候, 会尽量抓取满足匹配的最长字符串

如果要求匹配的字符越少越好, 需要加上?
即非贪婪匹配
例如 .+?

"""